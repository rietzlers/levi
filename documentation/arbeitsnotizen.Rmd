---
title: "Arbeitsnotizen"
author: "Stephan Rietzler"
date: "12/17/2019"
output: 
  html_notebook:
    code_folding: hide
---

```{r include=FALSE}
library(tidyverse)
library(magrittr)
library(zeallot)
library(cowplot)
library(plotly)
library(shiny)
library(janitor)
library(levi)
```


# Daten-Handling

 - Laden der axial-oder radial-datensätze; 
 Momentan nur jeweils einen Datensatz
 - Festlegung der Heizpulse und Abkühlungsphase
 - Einlesen/Eingabe der Proben-Daten: 
 radius, masse, schmelztemperatur
 - Möglichkeit die bearbeiteten Datensätze mit gewählten 
 Parameter zu speichern. 

# Signal-Analysis

Auswahl eines Signals und Zeitfensters. Bestimmung der dominanten 
Frequenz in diesem Zeitfenster. Glättung!?

# Frequenz-Schätzer

Die *dominante Schwingungs-Frequenz* der Kugel kann aus den zur Verfügung stehenden Signalen
auf unterschiedliche Art ermittelt werden: 

 - Die zur maximalen Amplitude der Fourier-Koeffizienten gehörende Frequenz.
 - Lorentz-Fit an das Betragsquadrat der Amplituden.

Dabei ist folgendes zu beachten: 

 -  Das Signal kann vorher aufbereitet werden (Glättung, Mittelung usw. )
 -  Die Fourier-Koeffizeienten können verschieden berechnet werden: 
 über die Standard-Funktion ```spectrum ``` oder mit   der Funktion ```fft```.

Numerische Probleme:
```{r}
N <- 2^3
phase <- seq(0, 2*pi, by = 0.01)
max_amp <- function(phase){max(abs(fft(20 * cos(2*pi*1.1*( seq(0, N-1) + phase ))))) * 2 / N}
plot(phase, purrr::map_dbl(phase, max_amp))
```

# Freq.-Bestimmung durch Lorentz-Fit

## Motivation

Ein gedämpfter harmonischer Oszillator gnügt folgender Gleichung: (siehe [Lorentz-Kurve](https://de.wikipedia.org/wiki/Lorentzkurve))
\[\ddot{x} + 2\gamma \dot{x} + \omega_0^2 x = f(t)\]
Die allgemeine Lösung ist:
\[x(t) = A \cdot e^{-\gamma\cdot t}\cdot sin\bigg(\sqrt{\omega_0^2 - \gamma^2}\cdot t) + \phi\bigg) + x_p(t) \]
wobei $x_p(t) \rightarrow 0$ für $t\rightarrow \infty$.   


Das **Betragsquadrat** der Fourier-Transformierten ist:
\[f(\omega) = \frac{|A(\omega)|^2}{(\omega^2 - \omega_0^2)^2 + \large(2\gamma\large)^2\omega^2} \]

Wobei $A(\omega)$ die Fouriertransformierte von $f(t)$ ist. Unterstellt man eine kurze Impulsanregung so kann
$A(\omega)$ als näherungsweise unabhängig von $\omega$ angesetzt werden.

Die theoretische Spektraldichte dieses Signals ist damit porportional zu:
\[f(\omega) \sim \frac{A}{(\omega^2 - \omega_0^2)^2 + \large(2\gamma\large)^2\omega^2} \]

Ein heuristischen Ansatz für die Modellierung der Oszillation der Kugeloberfläche ist der gedämpfte
harmonische Oszillator.  Aus diesem Grund wird einel Lorentz-Kurve an die quadrierten 
Amplituden der Fourier-Frequenzen gefittet und daraus die Eigen-Frequenz $\omega_0$ 
und die Dämpfung $\lambda$ ermittelt.

## Einschränkungen

* Für $\omega \rightarrow \infty$ geht die Lorentz-Kurve gegen Null. Die
Amplituden-Werte der Fourie-Koeffizeinten repräsentieren aber hochfrequentes
Rauschen und bleiben deswegen (statistisch) positiv endlich. Die Anpassung der
Lorentz-Kurve muß auf ein Frequenz-Band um die dominante Freq. beschränkt werden.
**Wie soll diese Breite festgelegt werden?**

* Das endliche sampling führt zu einer Verbreiterung des theoretischen 
Spektrums: Ein Rechteck-Taper hat die Fejer-Funktion als Spektralfenster.
Als 'Maß' für die Breite des Fejer-Fensters kann man als richtwert eine
Fourier-Frequenz setzen. Also 1/N $\cdot$ samplerate = $1/T$ wobei T die 
Beobachtungs-Dauer bzw. Länge des Taper-Fensters ist.

```{r}
fejer <- function(w, N){if_else(w==0, N, 1/N*(sin(pi*w*N)/sin(pi*w))^2)}
w <- seq(-0.5, 0.5, by = .0001)

d <- tidyr::expand_grid(w, N = 2^seq(6,9)) %>% mutate(famps = fejer(w,N))

fejer_graph <- 
  d %>% 
  group_by(N) %>%  
  mutate(
    f = w*N, # alle signale werden eine sekunde aufgezeichnet -> sr = 1/N 
    damping = log10(famps/max(famps, na.rm = TRUE))
    ) %>% 
  ungroup() %>% 
  filter(!(near(abs(w), 0.5))) %>% 
  ggplot(aes(x = f, y = damping)) + 
  geom_line(aes(color = factor(N))) +
ylim(c(-40, 0))

fejer_graph %>% plotly::ggplotly()
```

Typische Werte der Frequenz sind von ca. 34 - 32Hz

```{r}
f_s <- function(st, m){sqrt(8/3*st/(pi*m))}
m <- 1.29224 / 1000
st <- 1.6
f_s(st, m)
```

Typische werte der Dämpfung: 0.5 - 0.3 

```{r}
eta <- 8.47/1000
r <- 3.264/1000
d <- function(r,m ){20*pi/3*r/m * eta}
d(r, m)
```

Erwartungswert direkter Spektralschätzer

```{r}
sr <- 50
srn <- nextn(sr, factors = c(2))
w0 <- 10.5
d <- 0.1
bp = c(w0 - 2 , w0 + 2)

fejer <- function(w, N){if_else(w==0, as.double(N), 1/N*(sin(pi*w*N)/sin(pi*w))^2)}

lorentz_spec <- function(w){w <- w*srn; 10^4/((w^2 - (w0)^2)^2 + (2*d)^2*w^2)}

exp_spec <- function(l, spec){
  integrand <- Vectorize(function(w){spec(w)*fejer(l-w, srn)}, vectorize.args = c("w"))
  integrate(integrand, -.5, .5, stop.on.error = FALSE)$value
}

ep_data <- 
  tibble(
    w = seq(0, .5, by = 1/srn),
    th_spec = lorentz_spec(w),
    expected_spec = map_dbl(w, exp_spec, lorentz_spec),
    f = w*srn,
    fc_amp = sqrt(rexp(n=length(f), r = 1/th_spec))
    )
  
c(params_complete, lf_complete, lfm_complete) %<-% (ep_data %>%  fit_lorentz(c0 = c(A = 10^4, f0 = w0, g = d)))
c(params_bp, lf_bp, lfm_bp) %<-% 
  (ep_data %>%  
     transmute(
       f = f,
       fc_amp =  if_else(
        between(f,  bp[1], bp[2]),
        fc_amp , # N = lenght(t): Normierung wieder rückgängig machen.
        NA_real_
        )
       ) %>% 
     filter(!is.na(fc_amp)) %>%
     # mutate(
     #   fc_amp = if_else(between(fc_amp, w0-2, w0+2), fc_amp * 4, fc_amp)
     # ) %>% 
     fit_lorentz(c0 = c(A = 10^4, f0 = w0, g = d)))

specs_plot <- 
  ep_data %>% 
  ggplot(aes(x = w)) +
  geom_line(data = tibble(w = seq(0, .5, by = 1/10^5), th_spec = lorentz_spec(w)), aes(y = th_spec), color = "red") +
  geom_vline(xintercept = w0/srn) +
  # expected at paded fourier-frequencies
  geom_point(aes(y = expected_spec), color = "blue", shape = "x") +
  geom_line(data = tibble(w = seq(0, .5, by = 1/10^3), expected_spec = map_dbl(w, exp_spec, lorentz_spec)),
            aes(x = w, y = expected_spec), color = "blue") +
  #expected at "sample-rate"-ff
  # geom_point(data = tibble(w = (0:(sr/2))/sr, fcamp = map_dbl(w, exp_spec, lorentz_spec)),
  #            aes(x = w, y = fcamp), color = "blue") +
  geom_point(aes(y= fc_amp^2), color = "green" , shape = "+") +
  geom_line(data = tibble(w = seq(0, .5, by = 1/10^5) , lf_amp = sqrt(predict(lfm_complete, newdata = list(f = w*srn)))), 
            aes(x = w, y = lf_amp^2), color = "green", linetype = "dashed") +
  geom_line(data = tibble(w = seq(0, .5, by = 1/10^5) , lf_amp = sqrt(predict(lfm_bp, newdata = list(f = w*srn)))), 
            aes(x = w, y = lf_amp^2), color = "orange") +
  scale_x_continuous(sec.axis = sec_axis(~ .*srn)) +
  #scale_y_continuous(trans = "log10") + 
  labs(
    title = str_glue("Estimates: f = {round(params_complete$estimate[2], 1)}/{round(params_bp$estimate[2],1)}, d = {round(params_complete$estimate[3], 1)}/{round(params_bp$estimate[3],1)}"))
    
#specs_plot #+ xlim(c(w0 - 10, w0 + 10)/srn)
specs_plot %>% ggplotly()


```

resultate:

 - Typische breite der Lorentz-kurve ist etw 1 Hz (bei d = 0.5). 
 D.h. bei einer Taper-Breite von ca. 1s liegt nur etwa ein 'Frequenz-Messwert'
 im 'nicht-null'-Teil der Kurve. Ist dieser Wert nicht gleich w0 so ...
 
